var we=t=>{throw TypeError(t)};var $=(t,e,n)=>e.has(t)||we("Cannot "+n);var a=(t,e,n)=>($(t,e,"read from private field"),n?n.call(t):e.get(t)),h=(t,e,n)=>e.has(t)?we("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),u=(t,e,n,s)=>($(t,e,"write to private field"),s?s.call(t,n):e.set(t,n),n),p=(t,e,n)=>($(t,e,"access private method"),n);import{l as ke,C as Ie,D as y,s as Y,E as q,G as We,H as ee,J as Te,K as Oe,L as Me,O as Ee,P as Ae,o as be,p as Re}from"./ScrollArea-CqSHRPTv.js";import{r as k}from"./Toast-DTVs7FW6.js";var D,r,z,f,E,F,W,R,G,J,L,U,Q,O,N,o,V,te,ne,ae,se,re,ie,de,ye,Ce,Ue=(Ce=class extends ke{constructor(e,n){super();h(this,o);h(this,D);h(this,r);h(this,z);h(this,f);h(this,E);h(this,F);h(this,W);h(this,R);h(this,G);h(this,J);h(this,L);h(this,U);h(this,Q);h(this,O);h(this,N,new Set);this.options=n,u(this,D,e),u(this,R,null),u(this,W,Ie()),this.options.experimental_prefetchInRender||a(this,W).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),this.bindMethods(),this.setOptions(n)}bindMethods(){this.refetch=this.refetch.bind(this)}onSubscribe(){this.listeners.size===1&&(a(this,r).addObserver(this),fe(a(this,r),this.options)?p(this,o,V).call(this):this.updateResult(),p(this,o,se).call(this))}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return oe(a(this,r),this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return oe(a(this,r),this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=new Set,p(this,o,re).call(this),p(this,o,ie).call(this),a(this,r).removeObserver(this)}setOptions(e,n){const s=this.options,l=a(this,r);if(this.options=a(this,D).defaultQueryOptions(e),this.options.enabled!==void 0&&typeof this.options.enabled!="boolean"&&typeof this.options.enabled!="function"&&typeof y(this.options.enabled,a(this,r))!="boolean")throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");p(this,o,de).call(this),a(this,r).setOptions(this.options),s._defaulted&&!Y(this.options,s)&&a(this,D).getQueryCache().notify({type:"observerOptionsUpdated",query:a(this,r),observer:this});const i=this.hasListeners();i&&De(a(this,r),l,this.options,s)&&p(this,o,V).call(this),this.updateResult(n),i&&(a(this,r)!==l||y(this.options.enabled,a(this,r))!==y(s.enabled,a(this,r))||q(this.options.staleTime,a(this,r))!==q(s.staleTime,a(this,r)))&&p(this,o,te).call(this);const d=p(this,o,ne).call(this);i&&(a(this,r)!==l||y(this.options.enabled,a(this,r))!==y(s.enabled,a(this,r))||d!==a(this,O))&&p(this,o,ae).call(this,d)}getOptimisticResult(e){const n=a(this,D).getQueryCache().build(a(this,D),e),s=this.createResult(n,e);return xe(this,s)&&(u(this,f,s),u(this,F,this.options),u(this,E,a(this,r).state)),s}getCurrentResult(){return a(this,f)}trackResult(e,n){const s={};return Object.keys(e).forEach(l=>{Object.defineProperty(s,l,{configurable:!1,enumerable:!0,get:()=>(this.trackProp(l),n==null||n(l),e[l])})}),s}trackProp(e){a(this,N).add(e)}getCurrentQuery(){return a(this,r)}refetch({...e}={}){return this.fetch({...e})}fetchOptimistic(e){const n=a(this,D).defaultQueryOptions(e),s=a(this,D).getQueryCache().build(a(this,D),n);return s.fetch().then(()=>this.createResult(s,n))}fetch(e){return p(this,o,V).call(this,{...e,cancelRefetch:e.cancelRefetch??!0}).then(()=>(this.updateResult(),a(this,f)))}createResult(e,n){var he;const s=a(this,r),l=this.options,i=a(this,f),d=a(this,E),g=a(this,F),m=e!==s?e.state:a(this,z),{state:v}=e;let c={...v},_=!1,I;if(n._optimisticResults){const T=this.hasListeners(),x=!T&&fe(e,n),P=T&&De(e,s,n,l);(x||P)&&(c={...c,...Ee(v.data,e.options)}),n._optimisticResults==="isRestoring"&&(c.fetchStatus="idle")}let{error:j,errorUpdatedAt:B,status:S}=c;if(n.select&&c.data!==void 0)if(i&&c.data===(d==null?void 0:d.data)&&n.select===a(this,G))I=a(this,J);else try{u(this,G,n.select),I=n.select(c.data),I=Ae(i==null?void 0:i.data,I,n),u(this,J,I),u(this,R,null)}catch(T){u(this,R,T)}else I=c.data;if(n.placeholderData!==void 0&&I===void 0&&S==="pending"){let T;if(i!=null&&i.isPlaceholderData&&n.placeholderData===(g==null?void 0:g.placeholderData))T=i.data;else if(T=typeof n.placeholderData=="function"?n.placeholderData((he=a(this,L))==null?void 0:he.state.data,a(this,L)):n.placeholderData,n.select&&T!==void 0)try{T=n.select(T),u(this,R,null)}catch(x){u(this,R,x)}T!==void 0&&(S="success",I=Ae(i==null?void 0:i.data,T,n),_=!0)}a(this,R)&&(j=a(this,R),I=a(this,J),B=Date.now(),S="error");const H=c.fetchStatus==="fetching",Z=S==="pending",X=S==="error",le=Z&&H,pe=I!==void 0,b={status:S,fetchStatus:c.fetchStatus,isPending:Z,isSuccess:S==="success",isError:X,isInitialLoading:le,isLoading:le,data:I,dataUpdatedAt:c.dataUpdatedAt,error:j,errorUpdatedAt:B,failureCount:c.fetchFailureCount,failureReason:c.fetchFailureReason,errorUpdateCount:c.errorUpdateCount,isFetched:c.dataUpdateCount>0||c.errorUpdateCount>0,isFetchedAfterMount:c.dataUpdateCount>m.dataUpdateCount||c.errorUpdateCount>m.errorUpdateCount,isFetching:H,isRefetching:H&&!Z,isLoadingError:X&&!pe,isPaused:c.fetchStatus==="paused",isPlaceholderData:_,isRefetchError:X&&pe,isStale:ce(e,n),refetch:this.refetch,promise:a(this,W)};if(this.options.experimental_prefetchInRender){const T=K=>{b.status==="error"?K.reject(b.error):b.data!==void 0&&K.resolve(b.data)},x=()=>{const K=u(this,W,b.promise=Ie());T(K)},P=a(this,W);switch(P.status){case"pending":e.queryHash===s.queryHash&&T(P);break;case"fulfilled":(b.status==="error"||b.data!==P.value)&&x();break;case"rejected":(b.status!=="error"||b.error!==P.reason)&&x();break}}return b}updateResult(e){const n=a(this,f),s=this.createResult(a(this,r),this.options);if(u(this,E,a(this,r).state),u(this,F,this.options),a(this,E).data!==void 0&&u(this,L,a(this,r)),Y(s,n))return;u(this,f,s);const l={},i=()=>{if(!n)return!0;const{notifyOnChangeProps:d}=this.options,g=typeof d=="function"?d():d;if(g==="all"||!g&&!a(this,N).size)return!0;const w=new Set(g??a(this,N));return this.options.throwOnError&&w.add("error"),Object.keys(a(this,f)).some(m=>{const v=m;return a(this,f)[v]!==n[v]&&w.has(v)})};(e==null?void 0:e.listeners)!==!1&&i()&&(l.listeners=!0),p(this,o,ye).call(this,{...l,...e})}onQueryUpdate(){this.updateResult(),this.hasListeners()&&p(this,o,se).call(this)}},D=new WeakMap,r=new WeakMap,z=new WeakMap,f=new WeakMap,E=new WeakMap,F=new WeakMap,W=new WeakMap,R=new WeakMap,G=new WeakMap,J=new WeakMap,L=new WeakMap,U=new WeakMap,Q=new WeakMap,O=new WeakMap,N=new WeakMap,o=new WeakSet,V=function(e){p(this,o,de).call(this);let n=a(this,r).fetch(this.options,e);return e!=null&&e.throwOnError||(n=n.catch(We)),n},te=function(){p(this,o,re).call(this);const e=q(this.options.staleTime,a(this,r));if(ee||a(this,f).isStale||!Te(e))return;const s=Oe(a(this,f).dataUpdatedAt,e)+1;u(this,U,setTimeout(()=>{a(this,f).isStale||this.updateResult()},s))},ne=function(){return(typeof this.options.refetchInterval=="function"?this.options.refetchInterval(a(this,r)):this.options.refetchInterval)??!1},ae=function(e){p(this,o,ie).call(this),u(this,O,e),!(ee||y(this.options.enabled,a(this,r))===!1||!Te(a(this,O))||a(this,O)===0)&&u(this,Q,setInterval(()=>{(this.options.refetchIntervalInBackground||Me.isFocused())&&p(this,o,V).call(this)},a(this,O)))},se=function(){p(this,o,te).call(this),p(this,o,ae).call(this,p(this,o,ne).call(this))},re=function(){a(this,U)&&(clearTimeout(a(this,U)),u(this,U,void 0))},ie=function(){a(this,Q)&&(clearInterval(a(this,Q)),u(this,Q,void 0))},de=function(){const e=a(this,D).getQueryCache().build(a(this,D),this.options);if(e===a(this,r))return;const n=a(this,r);u(this,r,e),u(this,z,e.state),this.hasListeners()&&(n==null||n.removeObserver(this),e.addObserver(this))},ye=function(e){be.batch(()=>{e.listeners&&this.listeners.forEach(n=>{n(a(this,f))}),a(this,D).getQueryCache().notify({query:a(this,r),type:"observerResultsUpdated"})})},Ce);function Qe(t,e){return y(e.enabled,t)!==!1&&t.state.data===void 0&&!(t.state.status==="error"&&e.retryOnMount===!1)}function fe(t,e){return Qe(t,e)||t.state.data!==void 0&&oe(t,e,e.refetchOnMount)}function oe(t,e,n){if(y(e.enabled,t)!==!1){const s=typeof n=="function"?n(t):n;return s==="always"||s!==!1&&ce(t,e)}return!1}function De(t,e,n,s){return(t!==e||y(s.enabled,t)===!1)&&(!n.suspense||t.state.status!=="error")&&ce(t,n)}function ce(t,e){return y(e.enabled,t)!==!1&&t.isStaleByTime(q(e.staleTime,t))}function xe(t,e){return!Y(t.getCurrentResult(),e)}var ge=k.createContext(!1),Pe=()=>k.useContext(ge);ge.Provider;function Fe(){let t=!1;return{clearReset:()=>{t=!1},reset:()=>{t=!0},isReset:()=>t}}var Je=k.createContext(Fe()),Le=()=>k.useContext(Je);function Ne(t,e){return typeof t=="function"?t(...e):!!t}function Se(){}var _e=(t,e)=>{(t.suspense||t.throwOnError||t.experimental_prefetchInRender)&&(e.isReset()||(t.retryOnMount=!1))},je=t=>{k.useEffect(()=>{t.clearReset()},[t])},Be=({result:t,errorResetBoundary:e,throwOnError:n,query:s,suspense:l})=>t.isError&&!e.isReset()&&!t.isFetching&&s&&(l&&t.data===void 0||Ne(n,[t.error,s])),He=t=>{const e=t.staleTime;t.suspense&&(t.staleTime=typeof e=="function"?(...n)=>Math.max(e(...n),1e3):Math.max(e??1e3,1e3),typeof t.gcTime=="number"&&(t.gcTime=Math.max(t.gcTime,1e3)))},Ve=(t,e)=>t.isLoading&&t.isFetching&&!e,ze=(t,e)=>(t==null?void 0:t.suspense)&&e.isPending,me=(t,e,n)=>e.fetchOptimistic(t).catch(()=>{n.clearReset()});function Ge(t,e,n){var c,_,I,j,B;const s=Re(),l=Pe(),i=Le(),d=s.defaultQueryOptions(t);(_=(c=s.getDefaultOptions().queries)==null?void 0:c._experimental_beforeQuery)==null||_.call(c,d),d._optimisticResults=l?"isRestoring":"optimistic",He(d),_e(d,i),je(i);const g=!s.getQueryCache().get(d.queryHash),[w]=k.useState(()=>new e(s,d)),m=w.getOptimisticResult(d),v=!l&&t.subscribed!==!1;if(k.useSyncExternalStore(k.useCallback(S=>{const H=v?w.subscribe(be.batchCalls(S)):Se;return w.updateResult(),H},[w,v]),()=>w.getCurrentResult(),()=>w.getCurrentResult()),k.useEffect(()=>{w.setOptions(d,{listeners:!1})},[d,w]),ze(d,m))throw me(d,w,i);if(Be({result:m,errorResetBoundary:i,throwOnError:d.throwOnError,query:s.getQueryCache().get(d.queryHash),suspense:d.suspense}))throw m.error;if((j=(I=s.getDefaultOptions().queries)==null?void 0:I._experimental_afterQuery)==null||j.call(I,d,m),d.experimental_prefetchInRender&&!ee&&Ve(m,l)){const S=g?me(d,w,i):(B=s.getQueryCache().get(d.queryHash))==null?void 0:B.promise;S==null||S.catch(Se).finally(()=>{w.updateResult()})}return d.notifyOnChangeProps?m:w.trackResult(m)}function Ke(t,e){return Ge(t,Ue)}async function ve(t){try{return{data:await t,error:null}}catch(e){return{data:null,error:e}}}const rt=[{id:1,title:"歡迎加入 論壇樣板！",content:"感謝您加入論壇樣板，希望您在這裡能找到有趣的討論。"},{id:2,title:"預計維護公告",content:"論壇樣板將於下週四的 10:00 AM 進行系統維護，預計需 2 小時。"},{id:3,title:"新留言通知",content:"您的貼文 'React 18 的並發模式值得升級嗎？' 有新留言。"}],M=[{id:2,name:"Alice Johnson",description:"前端開發者和 React 愛好者。"},{id:3,name:"Bob Smith",description:"UI/UX 設計師和 CSS 愛好者。"},{id:4,name:"Charlie Brown",description:"網頁效能工程師和 Vite 粉絲。"},{id:5,name:"David Lee",description:"全端開發者和 Next.js 專家。"},{id:6,name:"Eve Walker",description:"安全研究員和身份驗證專家。"},{id:7,name:"Frank Harris",description:"React 開發者和 Zustand 使用者。"},{id:8,name:"Grace Miller",description:"UI 設計師和 shadcn/ui 貢獻者。"},{id:9,name:"Henry Wilson",description:"React 開發者和 Server Components 倡導者。"},{id:10,name:"Isabella Carter",description:"後端開發者和 Supabase 使用者。"},{id:11,name:"Jack Anderson",description:"前端開發者和 React Query/SWR 使用者。"},{id:12,name:"Karen Martinez",description:"網頁效能專家和優化愛好者。"},{id:13,name:"Liam Rodriguez",description:"後端開發者和 Bun 愛好者。"},{id:14,name:"Mia Thompson",description:"WebAssembly 愛好者和效能專家。"},{id:15,name:"Noah White",description:"前端開發者和技術趨勢追隨者。"},{id:16,name:"Olivia Lewis",description:"前端開發者和 Turbopack 使用者。"},{id:1,name:"1ureka",description:""}],C=()=>{const t=Math.floor(Math.random()*1e3)+1e3,e=Math.random().toString(36).substring(7);return new File([new ArrayBuffer(t)],`${e}.pdf`,{type:"application/pdf"})},A=t=>({authorId:M[t].id,author:M[t].name,authorDescription:M[t].description}),it=[{id:1,title:"React 18 的並發模式值得升級嗎？",...A(0),content:`React 18 帶來了並發模式，這是一個讓 UI 更新更流暢的重要變革。

    並發模式的核心在於讓 React 可以中斷與恢復渲染，這樣在處理大型應用時，不會因為一次性渲染過多內容而導致畫面卡頓。例如，使用 startTransition 來標記較低優先級的更新，React 會在有閒置時間時處理這些更新，而不會影響高優先級的操作，如用戶輸入。這不僅提升了用戶體驗，也讓開發者可以更靈活地管理狀態更新。

    但是，並發模式也有一些限制，例如對於某些非同步操作的處理可能會有問題，需要開發者注意。總的來說，React 18 的並發模式是一個值得升級的特性，尤其是對於需要處理大量數據或複雜動畫的應用來說。`,tags:["React","並發模式","效能優化","前端開發"],photos:[{name:"test",url:"test"},{name:"test",url:"test"}],viewCount:1024,likeCount:250,replyCount:30,createdAt:new Date("2024-03-01"),updatedAt:new Date("2024-03-01")},{id:2,title:"Tailwind CSS vs. MUI：哪個適合你的專案？",...A(1),content:`在前端開發中，選擇適合的 UI 框架會直接影響專案的成敗。Tailwind CSS 和 MUI 是目前兩個熱門選項，但各有特色，適用於不同場景。

Tailwind CSS：自由與靈活
Tailwind 是功能類優先（utility-first）的 CSS 框架，提供大量可組合的工具類。
- 優點：高度自定義、無需自定義 CSS、小體積、開發速度快。
- 缺點：學習曲線陡峭、HTML 標記臃腫、無障礙支援不足、需自行建立元件系統。

MUI：設計系統與效率
MUI 基於 Google Material Design，提供完整設計系統與豐富元件庫。
- 優點：預製元件豐富、主題系統強大、一致性佳、內建無障礙支援、社區活躍。
- 缺點：打包體積較大、默認樣式明顯、依賴 JavaScript、簡單專案可能過於複雜。

如何選擇？
- 選擇 Tailwind：適合需要高度自定義、快速開發、小型專案或性能敏感的應用。
- 選擇 MUI：適合企業級應用、時間有限、重視無障礙功能，或需要設計系統支援的專案。

個人觀點
我更偏好 MUI，因為它提供完整的設計系統，確保視覺一致性；元件庫成熟，節省開發時間；主題系統靈活，適應不同需求。

結論
Tailwind 與 MUI 各有優缺點，關鍵在於專案需求與團隊技能。甚至可將兩者結合，使用 MUI 元件系統配合 Tailwind 進行細微樣式調整，達到最佳效果。`,tags:["CSS","MUI","Tailwind","前端設計"],attachments:[C()],viewCount:1987,likeCount:410,replyCount:75,createdAt:new Date("2024-03-05"),updatedAt:new Date("2024-03-07")},{id:3,title:"Vite 為何比 Webpack 更快？",...A(2),content:"Vite 採用了原生 ES 模組與即時編譯技術，大幅提升開發速度。傳統的 Webpack 需要在開發時先進行整個專案的打包，這可能導致冷啟動時間過長，尤其是專案規模變大時。而 Vite 則透過 ES 模組的 import 方式，僅在瀏覽器需要時載入對應的模組，避免了不必要的打包過程。此外，Vite 內建的 HMR（熱模組替換）機制，使得開發者可以即時看到代碼變更的效果，減少重新整理的時間。這使 Vite 在開發體驗上遠優於 Webpack，特別是對於大型前端專案而言。",tags:["Vite","Webpack","效能","前端工具"],viewCount:2356,likeCount:590,replyCount:88,createdAt:new Date("2024-03-10"),updatedAt:new Date("2024-03-10")},{id:4,title:"Next.js 14 有哪些新特性值得關注？",...A(3),content:`Next.js 14 帶來了多項重要更新，包括 Server Actions、App Router 以及更優化的效能提升。

    Server Actions 讓開發者可以在伺服器端直接執行處理邏輯，減少 API 請求的成本，而 App Router 則進一步加強了應用的組織結構，使開發更具彈性。

    此外，Next.js 14 在預渲染與快取機制上也有所提升，讓頁面加載速度更快。這些新特性讓 Next.js 成為前端框架中更具吸引力的選擇，特別是對於需要伺服器端渲染的應用而言。`,tags:["Next.js","SSR","前端框架","效能提升"],attachments:[C(),C()],viewCount:3120,likeCount:720,replyCount:120,createdAt:new Date("2024-03-15"),updatedAt:new Date("2024-03-15")},{id:5,title:"前端開發中的 JWT 與 Session 安全性探討",...A(4),content:"JWT 與 Session 各有優缺點，如何確保應用程式的安全性？",tags:["JWT","Session","身份驗證","安全性"],viewCount:1780,likeCount:460,replyCount:95,createdAt:new Date("2024-03-20"),updatedAt:new Date("2024-03-20")},{id:6,title:"如何使用 Zustand 管理 React 狀態？",...A(5),content:"Zustand 是一個輕量級的狀態管理工具，比 Redux 更簡單，適合小型專案。",tags:["React","Zustand","狀態管理","前端開發"],photos:[{name:"test",url:"test"}],attachments:[C(),C(),C()],viewCount:1250,likeCount:310,replyCount:60,createdAt:new Date("2024-03-25"),updatedAt:new Date("2024-03-27")},{id:7,title:"為什麼你應該考慮使用 shadcn/ui？",...A(6),content:"shadcn/ui 提供了可擴展的 UI 元件，適合喜歡 Tailwind CSS 的開發者。",tags:["shadcn/ui","Tailwind","React","UI 元件"],viewCount:890,likeCount:190,replyCount:45,createdAt:new Date("2024-03-30"),updatedAt:new Date("2024-04-01")},{id:8,title:"Server Components 是未來嗎？",...A(7),content:`React Server Components（RSC）是 React 的一項重要新技術，它允許部分組件在伺服器端渲染，並將結果傳遞給前端。這種方式可以顯著減少瀏覽器端的 JavaScript 負擔，提升效能並減少加載時間。
    例如，某些不需要用戶互動的組件可以完全由伺服器處理，避免前端處理不必要的渲染。
    雖然目前 RSC 仍然在發展中，但它提供了一種全新的開發模式，未來可能會成為大型應用的標準解決方案。`,tags:["React","Server Components","SSR","效能優化"],attachments:Array.from({length:6},C),viewCount:2600,likeCount:680,replyCount:110,createdAt:new Date("2024-04-02"),updatedAt:new Date("2024-04-05")},{id:9,title:"如何使用 Supabase 建立完整的後端？",...A(8),content:`Supabase 是一個開源的 Firebase 替代方案，提供即時資料庫、身份驗證與存儲功能。

    使用 Supabase，可以快速建立一個完整的後端，無需自行管理伺服器。例如，透過 Supabase 的 Postgres 資料庫，可以輕鬆建立關聯式數據表，並使用 RLS（Row-Level Security）確保數據安全。此外，Supabase 內建的 WebSocket 支援讓前端能夠即時監聽資料變更，實現即時更新的功能。對於希望減少後端開發成本的前端工程師來說，Supabase 是一個非常理想的選擇。`,tags:["Supabase","後端","資料庫","身份驗證"],viewCount:1450,likeCount:350,replyCount:65,createdAt:new Date("2024-04-07"),updatedAt:new Date("2024-04-07")},{id:10,title:"React Query vs. SWR：哪個資料請求庫更好？",...A(9),content:"React Query 和 SWR 都是處理 API 資料請求的強大工具，各有優勢。",tags:["React","React Query","SWR","API 處理"],photos:[{name:"test",url:"test"},{name:"test",url:"test"}],viewCount:1875,likeCount:500,replyCount:85,createdAt:new Date("2024-04-12"),updatedAt:new Date("2024-04-15")},{id:11,title:"如何讓你的 Web 應用跑得更快？",...A(10),content:"透過代碼分割、預載資源和使用 CDN，可以讓 Web 應用加速。",tags:["效能優化","Web 開發","CDN","前端最佳化"],photos:[{name:"test",url:"test"},{name:"test",url:"test"},{name:"test",url:"test"}],viewCount:2240,likeCount:610,replyCount:130,createdAt:new Date("2024-04-18"),updatedAt:new Date("2024-04-20")},{id:12,title:"為什麼 Bun 可能會取代 Node.js？",...A(11),content:"Bun 具備更快的運行速度、更好的原生支援，成為 Node.js 的強勁對手。",tags:["Bun","Node.js","JavaScript","後端開發"],viewCount:2025,likeCount:490,replyCount:95,createdAt:new Date("2024-04-25"),updatedAt:new Date("2024-04-28")},{id:13,title:"WebAssembly (WASM) 能提升前端效能嗎？",...A(12),content:"WASM 可以執行高效能程式碼，讓 Web 應用運行更快。",tags:["WASM","效能","Web 開發","JavaScript"],viewCount:1350,likeCount:290,replyCount:50,createdAt:new Date("2024-04-28"),updatedAt:new Date("2024-05-01")},{id:14,title:"2025 年前端趨勢：你應該學哪些技術？",...A(13),content:"探索 2025 年最值得學習的前端技術，包括 React Server Components、Edge Functions 等。",tags:["前端趨勢","新技術","Web 開發","React"],photos:Array.from({length:10},(t,e)=>({name:`test${e}`,url:"test"})),attachments:[C(),C(),C()],viewCount:3105,likeCount:840,replyCount:170,createdAt:new Date("2024-05-01"),updatedAt:new Date("2024-05-03")},{id:15,title:"如何使用 Turbopack 加速你的前端專案？",...A(14),content:"Turbopack 作為 Webpack 的接班人，能讓前端開發更快速。",tags:["Turbopack","Webpack","前端工具","效能提升"],attachments:[C(),C()],viewCount:1640,likeCount:420,replyCount:78,createdAt:new Date("2024-05-05"),updatedAt:new Date("2024-05-05")}],qe=t=>({authorId:M[t-2].id,author:M[t-2].name,authorDescription:M[t-2].description}),Ze=[{id:1,postId:1,userId:4,content:"非常同意作者的觀點，並發模式確實解決了很多效能問題，特別是在處理大量資料的應用程式中。",createdAt:new Date("2024-03-01T10:15:00"),updatedAt:new Date("2024-03-01T10:15:10")},{id:2,postId:1,userId:7,content:"我最近在一個專案中實作了 startTransition，確實讓用戶體驗提升不少，尤其是在資料載入時的反應速度。",createdAt:new Date("2024-03-01T11:30:00"),updatedAt:new Date("2024-03-01T11:30:00")},{id:3,postId:1,userId:10,content:"雖然並發模式很好，但升級時需要注意某些第三方庫的相容性問題，我遇到過一些 UI 庫不相容的情況。",createdAt:new Date("2024-03-01T13:45:00"),updatedAt:new Date("2024-03-01T13:45:00")},{id:4,postId:1,userId:3,content:"有人可以分享一下實際使用 useTransition 的經驗嗎？我還在考慮是否要在專案中導入。",createdAt:new Date("2024-03-01T15:20:00"),updatedAt:new Date("2024-03-01T15:20:10")},{id:5,postId:1,userId:9,content:"除了並發模式，React 18 的自動批次處理(Automatic Batching)也是一個很棒的功能，可以減少渲染次數。",createdAt:new Date("2024-03-01T16:10:00"),updatedAt:new Date("2024-03-01T16:10:00")},{id:6,postId:1,userId:12,content:"我覺得作者低估了並發模式的學習曲線，對於小型團隊來說可能不值得為此升級。",createdAt:new Date("2024-03-01T17:30:00"),updatedAt:new Date("2024-03-01T17:30:00")},{id:7,postId:1,userId:5,content:"想請問一下，有沒有推薦的教學資源來學習這些新功能？官方文件有點太技術性了。",createdAt:new Date("2024-03-01T19:05:00"),updatedAt:new Date("2024-03-01T19:05:00")},{id:8,postId:1,userId:14,content:"效能優化不應該只依賴框架的新功能，良好的代碼結構和懂得使用 useMemo/useCallback 同樣重要。",createdAt:new Date("2024-03-01T20:40:00"),updatedAt:new Date("2024-03-01T20:40:10")},{id:9,postId:1,parentId:3,userId:6,content:"我也遇到過這個問題！特別是一些動畫庫，有時會有奇怪的行為。你遇到問題的是哪個庫？",createdAt:new Date("2024-03-01T14:15:00"),updatedAt:new Date("2024-03-01T14:15:00")},{id:10,postId:1,parentId:9,userId:10,content:"主要是 react-spring 和一些比較老的 UI 庫，需要做不少調整才能正常運作。",createdAt:new Date("2024-03-01T14:30:00"),updatedAt:new Date("2024-03-01T14:30:00")},{id:11,postId:1,parentId:4,userId:7,content:"我們在一個有大量表格資料的應用中使用了 useTransition，當用戶篩選資料時體驗好很多，界面不會卡頓。",createdAt:new Date("2024-03-01T15:45:00"),updatedAt:new Date("2024-03-01T15:45:00")},{id:12,postId:1,parentId:11,userId:3,content:"感謝分享！這正是我們專案中遇到的情況，看來值得一試。",createdAt:new Date("2024-03-01T16:00:00"),updatedAt:new Date("2024-03-01T16:00:00")},{id:13,postId:1,parentId:7,userId:8,content:"我推薦 'React Working Group' 的 YouTube 頻道，他們有很多關於 React 18 新功能的實用教學。",createdAt:new Date("2024-03-01T19:20:00"),updatedAt:new Date("2024-03-01T19:20:00")},{id:14,postId:1,parentId:7,userId:11,content:"Josh Comeau 的部落格也有一些很好的文章介紹並發模式，解釋得很清楚。",createdAt:new Date("2024-03-01T19:40:00"),updatedAt:new Date("2024-03-01T19:40:00")},{id:15,postId:1,parentId:6,userId:2,content:"我不完全同意。雖然有學習曲線，但即使是小團隊也能從並發模式中獲益，特別是處理表單輸入時。",createdAt:new Date("2024-03-01T18:00:00"),updatedAt:new Date("2024-03-01T18:00:00")},{id:16,postId:1,userId:13,content:"有人測試過並發模式在移動設備上的效能差異嗎？我很好奇在低端手機上的表現如何。",createdAt:new Date("2024-03-01T21:15:00"),updatedAt:new Date("2024-03-01T21:15:00")},{id:17,postId:1,parentId:16,userId:15,content:"我們有在各種Android設備上測試過，在低端設備上效果更明顯，因為並發模式能更好地管理有限的計算資源。",createdAt:new Date("2024-03-01T21:35:00"),updatedAt:new Date("2024-03-01T21:35:00")},{id:18,postId:1,parentId:8,userId:14,content:"補充一點，React 18的並發模式和良好的代碼結構結合起來使用，效果會更好。兩者不是互斥的關係。",createdAt:new Date("2024-03-01T22:10:00"),updatedAt:new Date("2024-03-01T22:10:00")},{id:19,postId:2,userId:5,content:"我個人更偏向 Tailwind CSS，它的工具類讓我開發速度提高了許多。",createdAt:new Date("2024-03-05T14:20:00"),updatedAt:new Date("2024-03-05T14:20:00")},{id:20,postId:2,userId:8,content:"MUI 的元件更完整，但也更難客製化。這是一個取捨問題。",createdAt:new Date("2024-03-06T09:30:00"),updatedAt:new Date("2024-03-06T09:30:00")},{id:21,postId:2,parentId:19,userId:3,content:"同意！但有時 Tailwind 的類名會讓 HTML 變得很雜亂，你有什麼解決方案嗎？",createdAt:new Date("2024-03-05T16:45:00"),updatedAt:new Date("2024-03-05T16:45:00")},{id:22,postId:3,userId:6,content:"Vite 的熱更新速度真的驚人，比 Webpack 快太多了。",createdAt:new Date("2024-03-11T10:15:00"),updatedAt:new Date("2024-03-11T10:15:00")},{id:23,postId:3,userId:12,content:"有人在大型專案中比較過兩者的建置時間嗎？",createdAt:new Date("2024-03-12T13:20:00"),updatedAt:new Date("2024-03-12T13:20:00")},{id:24,postId:3,parentId:23,userId:9,content:"我們的專案有約 200 個元件，從 Webpack 轉到 Vite 後，建置時間從 2 分鐘降到了 40 秒左右。",createdAt:new Date("2024-03-12T14:10:00"),updatedAt:new Date("2024-03-12T14:10:00")},{id:25,postId:4,userId:11,content:"Server Actions 真的很棒，省去了寫很多 API 端點的麻煩。",createdAt:new Date("2024-03-16T11:30:00"),updatedAt:new Date("2024-03-16T11:30:00")},{id:26,postId:4,userId:14,content:"Next.js 14 的優化讓頁面載入速度提升了不少，用戶體驗大幅改善。",createdAt:new Date("2024-03-17T15:45:00"),updatedAt:new Date("2024-03-17T15:45:00")},{id:27,postId:4,parentId:25,userId:7,content:"Server Actions 是怎麼處理錯誤的？有什麼最佳實踐嗎？",createdAt:new Date("2024-03-16T16:20:00"),updatedAt:new Date("2024-03-16T16:20:00")},{id:28,postId:4,parentId:27,userId:11,content:"通常我會使用 try/catch 並回傳一個統一的錯誤格式，然後在前端處理這些錯誤。",createdAt:new Date("2024-03-16T17:05:00"),updatedAt:new Date("2024-03-16T17:05:00")},{id:29,postId:7,userId:3,content:"shadcn/ui 的元件庫自由度很高，我很喜歡它的設計理念。",createdAt:new Date("2024-03-31T10:15:00"),updatedAt:new Date("2024-03-31T10:15:00")},{id:30,postId:8,userId:10,content:"Server Components 確實是未來趨勢，特別是對於需要 SEO 的網站來說。",createdAt:new Date("2024-04-03T13:45:00"),updatedAt:new Date("2024-04-03T13:45:00")},{id:31,postId:7,parentId:29,userId:8,content:"同意！我喜歡它不像其他 UI 庫那樣強制使用特定風格。",createdAt:new Date("2024-03-31T11:20:00"),updatedAt:new Date("2024-03-31T11:20:10")},{id:32,postId:9,userId:5,content:"Supabase 的即時訂閱功能真的很強大，很適合需要即時更新的應用。",createdAt:new Date("2024-04-08T14:30:00"),updatedAt:new Date("2024-04-08T14:30:00")},{id:33,postId:9,userId:10,content:"資料安全性方面，Supabase 的 RLS 政策設置有點複雜，有沒有好的學習資源？",createdAt:new Date("2024-04-09T09:15:00"),updatedAt:new Date("2024-04-09T09:15:00")},{id:34,postId:10,userId:11,content:"我用過兩者，最終選擇了 React Query，感覺它的功能更全面一些。",createdAt:new Date("2024-04-13T10:20:00"),updatedAt:new Date("2024-04-13T10:20:00")},{id:35,postId:10,parentId:34,userId:7,content:"我覺得 SWR 更簡單，適合小型專案。React Query 的確功能強大，但有時候有點過度。",createdAt:new Date("2024-04-13T15:40:00"),updatedAt:new Date("2024-04-13T15:40:00")},{id:36,postId:11,userId:12,content:"代碼分割是我個人認為最有效的優化手段之一，尤其對於大型應用。",createdAt:new Date("2024-04-19T11:30:00"),updatedAt:new Date("2024-04-19T11:30:00")},{id:37,postId:11,userId:4,content:"除了技術優化，圖片格式選擇和壓縮也很重要，WebP 可以節省很多流量。",createdAt:new Date("2024-04-21T09:45:00"),updatedAt:new Date("2024-04-21T09:45:00")},{id:38,postId:12,userId:13,content:"Bun 的效能確實驚人，但我擔心生態系統是否足夠成熟。",createdAt:new Date("2024-04-26T13:25:00"),updatedAt:new Date("2024-04-26T13:25:00")},{id:39,postId:12,parentId:38,userId:15,content:"生態系統正在快速成長，主流套件大多已支援。我覺得值得一試。",createdAt:new Date("2024-04-27T10:35:00"),updatedAt:new Date("2024-04-27T10:35:00")},{id:40,postId:13,userId:14,content:"我在一個圖像處理應用中使用 WASM，效能提升約 5 倍，非常顯著。",createdAt:new Date("2024-04-29T14:20:00"),updatedAt:new Date("2024-04-29T14:20:00")},{id:41,postId:13,userId:6,content:"WASM 的學習曲線如何？需要懂 C++ 或 Rust 嗎？",createdAt:new Date("2024-04-30T11:10:00"),updatedAt:new Date("2024-04-30T11:10:00")},{id:42,postId:13,parentId:41,userId:14,content:"不一定需要，現在有很多工具可以從 TypeScript 編譯到 WASM，如 AssemblyScript。",createdAt:new Date("2024-04-30T15:30:00"),updatedAt:new Date("2024-04-30T15:30:00")},{id:43,postId:14,userId:15,content:"Edge Functions 確實是趨勢，尤其是需要低延遲的全球應用。",createdAt:new Date("2024-05-02T09:15:00"),updatedAt:new Date("2024-05-02T09:15:00")},{id:44,postId:14,userId:2,content:"AI 輔助開發工具也是 2025 年值得關注的領域，能顯著提升生產力。",createdAt:new Date("2024-05-02T14:50:00"),updatedAt:new Date("2024-05-02T14:50:00")},{id:45,postId:14,parentId:44,userId:9,content:"有推薦的 AI 開發工具嗎？我目前只用 GitHub Copilot。",createdAt:new Date("2024-05-02T16:20:00"),updatedAt:new Date("2024-05-02T16:20:00")},{id:46,postId:14,parentId:45,userId:2,content:"Copilot 是最強大的，但也可以試試 Tabnine 或 AWS CodeWhisperer，各有特色。",createdAt:new Date("2024-05-02T17:45:00"),updatedAt:new Date("2024-05-02T17:45:00")},{id:47,postId:15,userId:16,content:"Turbopack 的增量編譯真的很快，但我發現它對某些 Webpack 插件還不太相容。",createdAt:new Date("2024-05-06T10:30:00"),updatedAt:new Date("2024-05-06T10:30:00")},{id:48,postId:15,userId:3,content:"有人在生產環境使用 Turbopack 嗎？穩定性如何？",createdAt:new Date("2024-05-07T13:40:00"),updatedAt:new Date("2024-05-07T13:40:00")},{id:49,postId:15,parentId:48,userId:16,content:"我們有幾個小專案在用，目前運行良好，但大型專案還是保守一點比較好。",createdAt:new Date("2024-05-07T16:15:00"),updatedAt:new Date("2024-05-07T16:15:00")},{id:50,postId:8,parentId:30,userId:2,content:"Server Components 確實解決了很多 SEO 問題，但需要注意元件設計和資料獲取模式。",createdAt:new Date("2024-04-03T16:20:00"),updatedAt:new Date("2024-04-03T16:20:00")},{id:51,postId:8,userId:5,content:"RSC 與 Client Components 的界限有時不太清楚，開發時需要特別注意。",createdAt:new Date("2024-04-04T11:30:00"),updatedAt:new Date("2024-04-04T11:30:00")},{id:52,postId:9,parentId:33,userId:10,content:"我找到了一個很好的 Supabase RLS 教學系列，晚點分享連結。",createdAt:new Date("2024-04-09T15:45:00"),updatedAt:new Date("2024-04-09T15:45:00")},{id:53,postId:11,parentId:36,userId:15,content:"動態載入也很重要，結合 Suspense 可以實現很好的載入體驗。",createdAt:new Date("2024-04-19T16:30:00"),updatedAt:new Date("2024-04-19T16:30:00")},{id:54,postId:5,userId:4,content:"JWT 的優點是無狀態，減輕了伺服器負擔，但如何處理 token 過期是個問題。有人使用刷新 token 的策略嗎？",createdAt:new Date("2024-03-21T09:30:00"),updatedAt:new Date("2024-03-21T09:30:00")},{id:55,postId:5,parentId:54,userId:10,content:"我們使用兩種 token：短期的 access token 和長期的 refresh token。當 access token 過期時，使用 refresh token 獲取新的 access token。",createdAt:new Date("2024-03-21T10:15:00"),updatedAt:new Date("2024-03-21T10:15:00")},{id:56,postId:5,parentId:55,userId:6,content:"這樣的雙 token 策略確實有效，但需要確保 refresh token 存儲在安全的地方，如 HttpOnly cookie。",createdAt:new Date("2024-03-21T11:45:00"),updatedAt:new Date("2024-03-21T11:45:00")},{id:57,postId:5,parentId:56,userId:4,content:"良好的建議！我之前將 refresh token 存在 localStorage 中，現在看來這不是最安全的做法。",createdAt:new Date("2024-03-21T13:20:00"),updatedAt:new Date("2024-03-21T13:20:00")},{id:58,postId:5,userId:8,content:"除了 JWT 和 Session，有人嘗試過使用 PASETO 嗎？它聲稱比 JWT 更安全。",createdAt:new Date("2024-03-21T14:30:00"),updatedAt:new Date("2024-03-21T14:30:00")},{id:59,postId:5,parentId:58,userId:14,content:"PASETO 確實解決了 JWT 的一些安全問題，但生態系統還不如 JWT 成熟。在大型專案中使用可能需要更多自定義工作。",createdAt:new Date("2024-03-21T15:10:00"),updatedAt:new Date("2024-03-21T15:10:00")},{id:60,postId:5,userId:3,content:"Session 在多伺服器環境中需要共享狀態，這是一個挑戰。有人使用 Redis 來解決這個問題嗎？",createdAt:new Date("2024-03-21T16:45:00"),updatedAt:new Date("2024-03-21T16:45:00")},{id:61,postId:5,parentId:60,userId:13,content:"是的，我們使用 Redis 存儲會話數據，它的高效能和支持過期時間的特性非常適合這個場景。",createdAt:new Date("2024-03-21T17:20:00"),updatedAt:new Date("2024-03-21T17:20:00")},{id:62,postId:5,userId:9,content:"關於 XSS 和 CSRF 防護，JWT 和 Session 都有各自的最佳實踐。JWT 需要注意不要在 localStorage 中存儲，而 Session 需要使用 CSRF token。",createdAt:new Date("2024-03-22T09:15:00"),updatedAt:new Date("2024-03-22T09:15:00")},{id:63,postId:5,parentId:62,userId:2,content:"對於 SPA 應用，我發現使用 SameSite=Strict 的 HttpOnly Cookie 存儲 JWT 是個不錯的平衡點。",createdAt:new Date("2024-03-22T10:30:00"),updatedAt:new Date("2024-03-22T10:30:00")},{id:64,postId:5,parentId:63,userId:11,content:"完全同意！這樣既能防止 XSS 攻擊（HttpOnly），又能避免 CSRF 攻擊（SameSite=Strict）。",createdAt:new Date("2024-03-22T11:45:00"),updatedAt:new Date("2024-03-22T11:45:00")},{id:65,postId:5,userId:7,content:"我們最近從 Session 轉向了 JWT，主要是為了支持微服務架構。但令人驚訝的是，我們發現伺服器的負載實際上增加了，因為每個請求都需要解析和驗證 JWT。",createdAt:new Date("2024-03-22T13:20:00"),updatedAt:new Date("2024-03-22T13:20:00")},{id:66,postId:5,parentId:65,userId:15,content:"這是個有趣的觀察！JWT 的計算成本確實會增加 CPU 負載。你們有考慮過使用快取來減輕這個問題嗎？",createdAt:new Date("2024-03-22T14:10:00"),updatedAt:new Date("2024-03-22T14:10:00")},{id:67,postId:5,parentId:66,userId:7,content:"是的，我們正在實施一個基於 Redis 的快取層，將有效的 JWT 和對應的用戶數據存儲一段時間。初步測試顯示這能減少約 70% 的 CPU 負載。",createdAt:new Date("2024-03-22T15:35:00"),updatedAt:new Date("2024-03-22T15:35:00")},{id:68,postId:5,parentId:67,userId:5,content:"這聽起來像是將 JWT 的無狀態優勢與 Session 的快取策略結合起來了。有趣的混合方法！",createdAt:new Date("2024-03-22T16:50:00"),updatedAt:new Date("2024-03-22T16:50:00")}],dt=Ze.map(t=>({...t,...qe(t.userId)})),ue="forum_session",Xe=M.find(t=>t.name==="1ureka")||M[0],$e=async()=>{const t=localStorage.getItem(ue);if(!t)return null;const e=await ve(Promise.resolve(JSON.parse(t)));return e.error?(console.error("讀取儲存的會話資訊失敗",e.error),null):e.data},Ye=async t=>{const e=await ve(Promise.resolve(localStorage.setItem(ue,JSON.stringify(t))));e.error&&console.error("儲存會話資訊失敗",e.error)},et=async()=>{await new Promise(e=>setTimeout(e,Math.random()*1e3));const t=await $e();return t&&t.authenticated?t:{authenticated:!1,user:null,loading:!1,error:null}},ot=()=>{const{data:t,isFetching:e,error:n}=Ke({queryKey:["session"],queryFn:et,staleTime:3e5});return e?{authenticated:!1,user:null,loading:!0,error:null}:n?{authenticated:!1,user:null,loading:!1,error:n instanceof Error?n.message:"未知錯誤"}:t||{authenticated:!1,user:null,loading:!1,error:null}},ct=()=>{const t=Re();return{login:async l=>{if(await new Promise(i=>setTimeout(i,1e3)),l.username&&l.password){const i={authenticated:!0,user:Xe,loading:!1,error:null};await Ye(i),t.setQueryData(["session"],i)}else console.error("帳號或密碼未輸入")},logout:async()=>{await new Promise(i=>setTimeout(i,1e3));const l={authenticated:!1,user:null,loading:!1,error:null};localStorage.removeItem(ue),t.setQueryData(["session"],l)},refreshSession:()=>{t.invalidateQueries({queryKey:["session"]})}}};export{Ue as Q,Ke as a,ot as b,dt as c,Ge as d,M as e,rt as f,Se as n,it as p,Ne as s,ct as u};
